statement ok
CREATE FUNCTION f1() RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE VIEW v_col_fn_ids AS
SELECT
id,
json_array_elements(
  crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor',
    descriptor,
    false
  )->'table'->'columns'
)->'id' as col_id,
json_array_elements(
  crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor',
    descriptor,
    false
  )->'table'->'columns'
)->'defaultExpr' as default_expr,
json_array_elements(
  crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor',
    descriptor,
    false
  )->'table'->'columns'
)->'onUpdateExpr' as on_update_expr,
json_array_elements(
  crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor',
    descriptor,
    false
  )->'table'->'columns'
)->'computeExpr' as compute_expr,
json_array_elements(
  crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor',
    descriptor,
    false
  )->'table'->'columns'
)->'usesFunctionIds' as uses_fn_ids
FROM system.descriptor

statement ok
CREATE FUNCTION get_col_fn_ids(table_id INT) RETURNS SETOF v_col_fn_ids
LANGUAGE SQL
AS $$
  SELECT *
  FROM v_col_fn_ids
  WHERE id = table_id
$$;

statement ok
CREATE VIEW v_fn_depended_on_by AS
SELECT
     id,
     jsonb_pretty(
       crdb_internal.pb_to_json(
         'cockroach.sql.sqlbase.Descriptor',
         descriptor,
         false
       )->'function'->'dependedOnBy'
     ) as depended_on_by
FROM system.descriptor

statement ok
CREATE FUNCTION get_fn_depended_on_by(function_id INT) RETURNS STRING
LANGUAGE SQL
AS $$
  SELECT depended_on_by
  FROM v_fn_depended_on_by
  WHERE id = function_id
$$;

# Make sure that column DEFAULT and ON UPDATE expressions are properly serialized
# and deserialized.
statement ok
CREATE TABLE t1(
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  c INT,
  d INT NULL ON UPDATE public.f1(),
  e INT,
  FAMILY fam_0 (a, b, c, d, e)
);

let $tbl_id
SELECT id FROM system.namespace WHERE name = 't1';

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,3,,,,)
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,,,)

skipif config local-schema-locked
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1];
----
CREATE TABLE public.t1 (
  a INT8 NOT NULL,
  b INT8 NULL DEFAULT public.f1(),
  c INT8 NULL,
  d INT8 NULL ON UPDATE public.f1(),
  e INT8 NULL,
  CONSTRAINT t1_pkey PRIMARY KEY (a ASC),
  FAMILY fam_0 (a, b, c, d, e)
);

onlyif config local-schema-locked
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1];
----
CREATE TABLE public.t1 (
  a INT8 NOT NULL,
  b INT8 NULL DEFAULT public.f1(),
  c INT8 NULL,
  CONSTRAINT t1_pkey PRIMARY KEY (a ASC),
  FAMILY fam_0 (a, b, c)
) WITH (schema_locked = true);

# Make sure that back references are tracked properly.
let $fn_id
SELECT oid::int - 100000 FROM pg_catalog.pg_proc WHERE proname = 'f1';

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            4
        ],
        "id": 111
    }
]

# Make sure SET DEFAULT sets cross references properly.
statement ok
ALTER TABLE t1 ALTER COLUMN c SET DEFAULT f1();

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,3,"""[FUNCTION 100106]()""",,,[106])
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,,,)

skipif config local-schema-locked
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1];
----
CREATE TABLE public.t1 (
  a INT8 NOT NULL,
  b INT8 NULL DEFAULT public.f1(),
  c INT8 NULL DEFAULT public.f1(),
  d INT8 NULL ON UPDATE public.f1(),
  e INT8 NULL,
  CONSTRAINT t1_pkey PRIMARY KEY (a ASC),
  FAMILY fam_0 (a, b, c, d, e)
);

skipif config local-schema-locked
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1];
----
CREATE TABLE public.t1 (
  a INT8 NOT NULL,
  b INT8 NULL DEFAULT public.f1(),
  c INT8 NULL DEFAULT public.f1(),
  d INT8 NULL ON UPDATE public.f1(),
  e INT8 NULL,
  CONSTRAINT t1_pkey PRIMARY KEY (a ASC),
  FAMILY fam_0 (a, b, c, d, e)
);

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            3,
            4
        ],
        "id": 111
    }
]

# Make sure SET ON UPDATE sets cross references properly.
statement ok
ALTER TABLE t1 ALTER COLUMN e SET ON UPDATE f1();

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,3,"""[FUNCTION 100106]()""",,,[106])
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""[FUNCTION 100106]()""",,[106])

skipif config local-schema-locked
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1];
----
CREATE TABLE public.t1 (
  a INT8 NOT NULL,
  b INT8 NULL DEFAULT public.f1(),
  c INT8 NULL DEFAULT public.f1(),
  d INT8 NULL ON UPDATE public.f1(),
  e INT8 NULL ON UPDATE public.f1(),
  CONSTRAINT t1_pkey PRIMARY KEY (a ASC),
  FAMILY fam_0 (a, b, c, d, e)
);

# Make sure cross references are properly removed with SET DEFAULT.
statement ok
ALTER TABLE t1 ALTER COLUMN c SET DEFAULT NULL;

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,3,,,,)
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""[FUNCTION 100106]()""",,[106])

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            4,
            5
        ],
        "id": 111
    }
]

# Make sure cross references are properly removed with SET ON UPDATE.
statement ok
ALTER TABLE t1 ALTER COLUMN e SET ON UPDATE NULL;

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,3,,,,)
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""NULL""",,)

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            4
        ],
        "id": 111
    }
]

# Make sure cross references are properly removed with DROP DEFAULT.
statement ok
ALTER TABLE t1 ALTER COLUMN b DROP DEFAULT;

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,,,,)
(111,3,,,,)
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""NULL""",,)

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            4
        ],
        "id": 111
    }
]

# Make sure cross references are properly removed with DROP ON UPDATE.
statement ok
ALTER TABLE t1 ALTER COLUMN d DROP ON UPDATE;

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,,,,)
(111,3,,,,)
(111,4,,,,)
(111,5,,"""NULL""",,)

query T
SELECT get_fn_depended_on_by($fn_id)
----
NULL

# Re-add references for the next test.
statement ok
ALTER TABLE t1 ALTER COLUMN b SET DEFAULT f1();

statement ok
ALTER TABLE t1 ALTER COLUMN d SET ON UPDATE f1();

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            4
        ],
        "id": 111
    }
]

# Make sure cross references are properly removed with DROP COLUMN.
statement ok
ALTER TABLE t1 ALTER COLUMN c SET DEFAULT f1();

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,3,"""[FUNCTION 100106]()""",,,[106])
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""NULL""",,)

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            3,
            4
        ],
        "id": 111
    }
]

statement ok
ALTER TABLE t1 DROP COLUMN c;

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""NULL""",,)

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            4
        ],
        "id": 111
    }
]

# Make sure adding a computed column, column with DEFAULT, and column with
# ON UPDATE updates function references.
statement ok
ALTER TABLE t1 ADD COLUMN f int AS (f1()) VIRTUAL;

statement ok
ALTER TABLE t1 ADD COLUMN g int DEFAULT (f1());

statement ok
ALTER TABLE t1 ADD COLUMN h int ON UPDATE (f1());

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""NULL""",,)
(111,6,,,"""[FUNCTION 100106]()""",[106])
(111,7,"""[FUNCTION 100106]()""",,,[106])
(111,8,,"""[FUNCTION 100106]()""",,[106])

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            4,
            6,
            7,
            8
        ],
        "id": 111
    }
]


# Make sure that cross references are properly remove with DROP TABLE.
statement ok
ALTER TABLE t1 ALTER COLUMN b SET DEFAULT f1();

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(111,1,,,,)
(111,2,"""[FUNCTION 100106]()""",,,[106])
(111,4,,"""[FUNCTION 100106]()""",,[106])
(111,5,,"""NULL""",,)
(111,6,,,"""[FUNCTION 100106]()""",[106])
(111,7,"""[FUNCTION 100106]()""",,,[106])
(111,8,,"""[FUNCTION 100106]()""",,[106])

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2,
            4,
            6,
            7,
            8
        ],
        "id": 111
    }
]

statement ok
DROP TABLE t1;

query T
SELECT get_fn_depended_on_by($fn_id)
----
NULL

# Make sure function used by multiple tables can handle cross-references
# properly.

statement ok
CREATE TABLE t1(
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  FAMILY fam_0 (a, b)
);
CREATE TABLE t2(
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  FAMILY fam_0 (a, b)
);

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2
        ],
        "id": 112
    },
    {
        "columnIds": [
            2
        ],
        "id": 113
    }
]

statement ok
DROP TABLE t1;
DROp TABLE t2;

query T
SELECT get_fn_depended_on_by($fn_id)
----
NULL

# Make sure table uses multiple functions can handle cross-references properly.
statement ok
CREATE FUNCTION f2() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

let $fn_id_2
SELECT oid::int - 100000 FROM pg_catalog.pg_proc WHERE proname = 'f2';

statement ok
CREATE TABLE t1(
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  c INT ON UPDATE f2(),
  FAMILY fam_0 (a, b, c)
);

query T
SELECT get_fn_depended_on_by($fn_id)
----
[
    {
        "columnIds": [
            2
        ],
        "id": 115
    }
]

query T
SELECT get_fn_depended_on_by($fn_id_2)
----
[
    {
        "columnIds": [
            3
        ],
        "id": 115
    }
]

statement ok
DROP TABLE t1;

query T
SELECT get_fn_depended_on_by($fn_id)
----
NULL

query T
SELECT get_fn_depended_on_by($fn_id_2)
----
NULL

# Make sure function cannot be dropped if used in constraints
statement ok
CREATE TABLE t1(
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  FAMILY fam_0 (a, b)
);
CREATE TABLE t2(
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  FAMILY fam_0 (a, b)
);

statement error pgcode 2BP01 cannot drop function "f1" because other objects \(\[test.public.t1, test.public.t2\]\) still depend on it
DROP FUNCTION f1;

statement ok
ALTER TABLE t1 ALTER COLUMN b SET DEFAULT NULL;
ALTER TABLE t2 ALTER COLUMN b SET DEFAULT NULL;

statement ok
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE t2;

# Make sure that CREATE FUNCTION and CREATE TABLE works in one txn.
statement ok
BEGIN;
CREATE FUNCTION f1() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE TABLE t1(
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  FAMILY fam_0 (a, b)
);
END;

let $tbl_id
SELECT id FROM system.namespace WHERE name = 't1';

let $fn_id
SELECT oid::int - 100000 FROM pg_catalog.pg_proc WHERE proname = 'f1';

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(119,1,,,,)
(119,2,"""[FUNCTION 100118]()""",,,[118])

query T
SELECT get_fn_depended_on_by($fn_id);
----
[
    {
        "columnIds": [
            2
        ],
        "id": 119
    }
]

statement ok
BEGIN;
DROP TABLE t1;
DROP FUNCTION f1;
END;

# Make sure that CREATE FUNCTION and SET DEFAULT works in one txn.
statement ok
CREATE TABLE t1 (
  a INT PRIMARY KEY,
  b INT,
  FAMILY fam_0 (a, b)
);

statement ok
CREATE FUNCTION f1() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
ALTER TABLE t1 ALTER COLUMN b SET DEFAULT f1();

let $tbl_id
SELECT id FROM system.namespace WHERE name = 't1';

let $fn_id
SELECT oid::int - 100000 FROM pg_catalog.pg_proc WHERE proname = 'f1';

query T rowsort
SELECT get_col_fn_ids($tbl_id);
----
(120,1,,,,)
(120,2,"""[FUNCTION 100121]()""",,,[121])

query T
SELECT get_fn_depended_on_by($fn_id);
----
[
    {
        "columnIds": [
            2
        ],
        "id": 120
    }
]

skipif config local-legacy-schema-changer
statement ok
SET use_declarative_schema_changer = 'unsafe_always';

statement ok
BEGIN;
ALTER TABLE t1 DROP COLUMN b;
DROP FUNCTION f1;
END;

skipif config local-legacy-schema-changer
statement ok
SET use_declarative_schema_changer = 'on';

# Make sure column DEFAULT works properly with insert.
statement ok
DROP TABLE t1;

statement ok
CREATE FUNCTION f1() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE TABLE t1 (
  a INT PRIMARY KEY,
  b INT DEFAULT f1(),
  FAMILY fam_0 (a, b)
);

statement ok
INSERT INTO t1 VALUES (1), (2)

query II
SELECT * FROM t1 ORDER BY a;
----
1  1
2  1

# Make sure that renaming a function is fine.
statement ok
ALTER FUNCTION f1() RENAME TO f1_new;

skipif config local-schema-locked
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1]
----
CREATE TABLE public.t1 (
  a INT8 NOT NULL,
  b INT8 NULL DEFAULT public.f1_new(),
  CONSTRAINT t1_pkey PRIMARY KEY (a ASC),
  FAMILY fam_0 (a, b)
);

onlyif config local-schema-locked
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1]
----
CREATE TABLE public.t1 (
  a INT8 NOT NULL,
  b INT8 NULL DEFAULT public.f1_new(),
  CONSTRAINT t1_pkey PRIMARY KEY (a ASC),
  FAMILY fam_0 (a, b)
) WITH (schema_locked = true);

statement ok
INSERT INTO t1 VALUES (3)

query II
SELECT * FROM t1 ORDER BY a;
----
1  1
2  1
3  1

# Test UDFs in computed columns.
statement ok
CREATE FUNCTION f_compute(x INT) RETURNS INT LANGUAGE SQL AS $$ SELECT x * 2 $$ IMMUTABLE;

statement ok
CREATE TABLE t_computed(
  a INT PRIMARY KEY,
  b INT,
  c INT AS (f_compute(a)) STORED,
  d INT AS (f_compute(b)) VIRTUAL
);

let $tbl_computed_id
SELECT id FROM system.namespace WHERE name = 't_computed';

# Check that computed column expressions track function usage.
query T rowsort
SELECT get_col_fn_ids($tbl_computed_id);
----
(125,1,,,,)
(125,2,,,,)
(125,3,,,"""[FUNCTION 100124](a)""",[124])
(125,4,,,"""[FUNCTION 100124](b)""",[124])

# Check function back references include computed columns.
let $fn_compute_id
SELECT oid::int - 100000 FROM pg_catalog.pg_proc WHERE proname = 'f_compute';

query T
SELECT get_fn_depended_on_by($fn_compute_id)
----
[
    {
        "columnIds": [
            3,
            4
        ],
        "id": 125
    }
]

# Test dropping computed column removes function references.
statement ok
ALTER TABLE t_computed DROP COLUMN c;

query T rowsort
SELECT get_col_fn_ids($tbl_computed_id);
----
(125,1,,,,)
(125,2,,,,)
(125,4,,,"""[FUNCTION 100124](b)""",[124])

query T
SELECT get_fn_depended_on_by($fn_compute_id)
----
[
    {
        "columnIds": [
            4
        ],
        "id": 125
    }
]

# Test dropping table removes all function references.
statement ok
DROP TABLE t_computed;

query T
SELECT get_fn_depended_on_by($fn_compute_id)
----
NULL

# Test computed column with multiple function references.
statement ok
CREATE FUNCTION f_add(x INT, y INT) RETURNS INT LANGUAGE SQL AS $$ SELECT x + y $$ IMMUTABLE;

statement ok
CREATE TABLE t_multi_fn(
  a INT PRIMARY KEY,
  b INT,
  c INT AS (f_compute(a) + f_add(a, b)) STORED
);

# Verify we can use the table.
statement ok
INSERT INTO t_multi_fn (a, b) VALUES (1, 2), (3, 4), (5, 6);

query III
SELECT * FROM t_multi_fn ORDER BY a;
----
1  2  5
3  4  13
5  6  21

let $tbl_multi_fn_id
SELECT id FROM system.namespace WHERE name = 't_multi_fn';

let $fn_add_id
SELECT oid::int - 100000 FROM pg_catalog.pg_proc WHERE proname = 'f_add';

# Check that computed column tracks multiple function references.
query T rowsort
SELECT get_col_fn_ids($tbl_multi_fn_id);
----
(127,1,,,,)
(127,2,,,,)
(127,3,,,"""[FUNCTION 100124](a) + [FUNCTION 100126](a, b)""","[124, 126]")

query T
SELECT get_fn_depended_on_by($fn_compute_id)
----
[
    {
        "columnIds": [
            3
        ],
        "id": 127
    }
]

query T
SELECT get_fn_depended_on_by($fn_add_id)
----
[
    {
        "columnIds": [
            3
        ],
        "id": 127
    }
]

statement ok
DROP TABLE t_multi_fn;

# Make sure dependency circle is not allowed.
statement ok
CREATE TABLE t_circle(a INT PRIMARY KEY, b INT);
CREATE FUNCTION f_circle() RETURNS INT LANGUAGE SQL AS $$ SELECT a FROM t_circle $$;

statement error pgcode 42P13 pq: .*cannot add dependency from descriptor \d+ to function f_circle \(\d+\) because there will be a dependency cycle.*
ALTER TABLE t_circle ALTER COLUMN b SET DEFAULT f_circle();
